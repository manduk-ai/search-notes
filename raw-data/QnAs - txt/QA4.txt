Q: What Python's module offers OO approached to filesystem paths?
Q: Give examples
A: pathlib
A: here = Path('.')  # instance of a Path subclass with current location.
A: here = here.resolve()  # Resolve symbolic links into an absolute path.
A: parent = here.parent  # Navigate up the chain of parents. 
A: child = here / 'subfolder' / 'subfile.txt'  # Navigate to a subfolder or subfile. 

Q: What is a general pattern to open a file in Python?
A: with open(filepath, mode) as f:
A:     # Use the file-like object `f`
A:     ...
A: Note: 'with' statement will close file after execution exits the block

Q: if we open a file f with the 'r' mode, what is type of object returned by f.read()?
A: It is str

Q: How to process CSV file (2 methods)
A: reader = csv.reader(f) or reader = csv.DictReader(f)
A: and then for row in reader:
A: one row of the reader(f) will give us list
A: and row of the DictReader(f) will give us a dictionary with header as a key 

Q: What is @property decorator?
A: It turn a method into a property. 
A: So it might be seen as a way for creating readonly properties. 
A: @property
A: def x(self):
A:    return self._x

Q: How to load csv file with proper exception handling?
A: try:
A:    f = open(fname, 'rb')
A: except OSError:
A:     print "Could not open/read file:", fname
A:     sys.exit()
A: 
A: with f:
A:    reader = csv.reader(f)
A:    for row in reader:
A:        pass #do stuff here

Q: How to measure time elapsed?
A: from timeit import default_timer as timer
A: start = timer()
A: # ...
A: end = timer()
A: print(end - start) # Time in seconds, e.g. 5.38091952400282

Q: What requirements.txt file is used for?
A: Commonly used filename for a list of all python library dependencies. 
A: Generated in the CLI with:
A: pip freeze > requirements.txt

Q: What is a pure function?
A: A method where the output is based solely on its inputs and
A: no variables outside the functionâ€™s scope are affected or changed.

Q: Difference between single underscore at the beginning, double underscore 
Q: at the beginning and double underscore at the beginning and at the end?
A: _single_leading_underscore: weak "internal use" indicator. 
A: from M import * does not import objects whose name starts with an underscore.
A: ------------
A: single_trailing_underscore_: used by convention to avoid conflicts 
A: with Python keyword, e.g. 
A: Tkinter.Toplevel(master, class_='ClassName')
A: ------------
A: __double_leading_underscore: when naming a class attribute, invokes 
A: name mangling (inside class FooBar, __boo becomes _FooBar__boo).
A: ------------
A: __double_leading_and_trailing_underscore__: "magic" objects or attributes 
A: that live in user-controlled namespaces. 
A: E.g. __init__, __import__ or __file__. 
A: Never invent such names; only use them as documented.

Q: How do you call those types of imports?
Q: 1) from os import open as open_
Q: 2) import package.module.class
Q: 3) from urllib import request
A: 1) partial import with aliasing
A: 2) absolute import / fully qualified import
A: 3) partial import without aliasing 

Q: How to implement abstract class and method?
A: By importing and inheriting the Abstract Base Class (ABC) 
A: and @abstractmethod decorator
A: from abc import ABC, abstractmethod
A: class someInterface(ABC):
A:     ....
A:     @abstractmethod
A:     def func(self):
A:         pass

Q: If you extend a class, how can you access the parent method's?
A: using the super() method
A: class BaseClass():
A:     def simple_method():
A:         return 'hello'
A: 
A: class SimpleClass(BaseClass):
A:     def simple_method():
A:         return super().simple_method() + ' world'

Q: What is Duck Typing?
A: Duck Typing is a type system used in dynamic languages, 
A: where the type or the class of an object 
A: is less important than the method it defines. 
A: Using Duck Typing, we do not check types at all.
A: We applicate the duck test: "If it walks like a duck and it quacks like a duck, then it must be a duck"
A: to determine whether an object can be used for a particular purpose

Q: Polymorhpism in Python
A: Polymorphism in python defines methods in the child class 
A: that have the same name as the methods in the parent class. 
A: Implemented in python for different purpose commonly Duck Typing, 
A: Operator and Method overloading, and Method overriding

Q: How to print 20! in scientific notation?
A: from math import factorial
A: var = factorial(20)
A: print(f'{var:.4e}')
A: >>> 2.4329e+18