Q: What is collections module and give examples.
A: This module implements specialized container datatypes providing alternatives 
A: to Python’s general purpose built-in containers, dict, list, set, and tuple.
A: Ex.1: Counter – dict subclass for counting hashable objects
A: Ex.2: defaultdict – dict subclass that calls a factory function to supply missing values
A: Ex.3: namedtuple – factory function for creating tuple subclasses with named fields

Q: What are generator expression and why use them?
A: gen = (costly_fn(data) for data in iterable)
A: next(gen)
A: They behave a bit like a "lazy list comprehension."
A: Use them if you want data-on-demand, but you might not want to compute all of it at once in memory
A: As a contract needle in [expensive_fn(item) for item in haystack]
A: will evaluate the entire list comprehension, and only then begins the search
A: Note generator expressions use parentheses instead of square brackets

Q: What would be the output of this code?
Q: ex = (x ** 2 for x in range(10))
Q: 16 in ex
Q: >>> ???
Q: list(ex)
Q: >>> ???
A: True
A: [25, 36, 49, 64, 81] - the rest of the generator expression

Q: What is a generator function?
A: It's like a normal function, except it contains the keyword yield.
A: When called, a generator function returns a generator iterator 
A: that can produce subsequent values on demand by running the function 
A: until it encounters a yield statement, and then pausing.
A: def func(n):
A:    for i in range(100):
A:       yield i**n
A: f = func(5)
A: next(f)

Q: What is a decorator and what are use cases?
A: A decorator is a transformation that can be applied to a function
A: They can be used to:
A: - handle shared behavior to append to functions, like printing argument
A: - cache return values to increase performance
A: - set a timeout on blocking functions
A: - mark class properties as "read-only"
A: - mark methods as static methods or class methods
A: - define event-driven handlers (for GUIs, or web-based clients)

Q: Write code for simple decorator that builds a wrapper function 
Q: and forwards arguments and return values to and from the captured function
A: import functools
A: def memoize(function):
A:     @functools.wraps(function)
A:     def wrapper(*args, **kwargs):
A:         return function(*args, **kwargs)
A:     return wrapper

Q: Write comprehention list with lambda expression
Q: It should square values from 0 to 9 only if a value is divisible by 4
A: [(lambda x: x*x)(x) for x in range(10) if x % 4 == 0]
A: >>> [0, 16, 64]
A: [lambda x: x*x for x in range(10) if x % 4 == 0] - this is wrong as 
A: it will produce 10 separate lambdas

Q: How to calculate variance of some list of ints - 3 ways
A: [1, 2, 3, 4, 5, 6, 4, 3, 2, 23, 5, 67, 7, 7]
A: np.sum((l - np.mean(l))**2) / len(l)
A: >>> 277.20918367346934
A: 
A: m = mean(l)
A: l2 = [(lambda x: (x - m)**2)(x) for x in l]
A: np.sum(l2) / len(l2)
A: >>> 277.20918367346934
A: 
A: v = np.var(l)

Q: How can we turn class method into a property?
A: By using @property decorator

Q: What does @staticmethod decorator do?
A: It behaves as normal function as it doesn't need class object nor instance object

Q: What does @classmethod decorator do?
A: The @classmethod decorator changes method call behavior by passing 
A: the class object, not the instance object, as the first argument.

Q: How to create private method or atribute in Python class?
A: There is no concept of private in Python classes
A: Use self._name convention to mark attribute as private

Q: What are Magic methods in Python?
A: Methods that allow us connect to the language
A: and leverage Python's polymorphism. E.g. get the size of an object
A: __len__  -> len(obj)
A: print object
A: __str__ -> str(x)
A: add objects
A: __add__ -> obj1 + obj2

Q: How produce infinite iterator?
A: From definition: iter(object, sentinel)
A: where sentinel is special value that is used to represent the end of a sequence
A: Hence: it = iter(int, 1) or it = iter(lamba:0, 1) will do the work

Q: How to check if variable is instance of particular type of object
A: We may use isinstance(object, type)
A: i = 4
A: isinstance(i,int) -> True 
A: isinstance(i,object) -> True 
A: isinstance(i,float) -> True 

Q: What method presents linearization of its superclass graph?
A: type.mro()
A: "method resolution order"
A: print(ZeroDivisionError.mro())
A: [ZeroDivisionError, ArithmeticError, Exception, BaseException, object]

Q: Explain exception handling
A: try:
A:     dangerous_code()
A: except SomeError:
A:     handle_the_error()
A: else: 
A:     handle_no_error()
A: finally:
A:     do_no_matter_what()

Q: Exception handling - how to handle multiple exceptions in one block?
A: try
A:    ...
A: except ValueError:
A:    ...
A: except (nameError, AttributeError):
A:    ...

Q: Exception handling - what happens whenr
Q: try
Q:    ...
Q: except:
Q:    ...
A: A bare except block captures all exceptions, including subclasses 
A: of BaseException like KeyboardInterrupt or SystemExit! 
A: This means that you almost never want except: and instead want to 
A: capture a specific class of errors
